# 2-3 ⑨的完美文本编辑器报告

## 实现思路

本题构建了一正一反两个双向链表(`list、list_rv`)，链表中的每个节点代表一个文本字符，将两个光标记为两个ListNode*型指针(`cursorL、cursorR 或 cursorL_、cursorR_`)。反向链表的作用主要是降低reverse操作的复杂度，其每一项操作只需与正向链表相反即可。

链表具体构造细节：ListNode结构体中记录结点的值、两个指向前驱和后继的指针以及插入结点的操作接口。List类中构造了头哨兵和尾哨兵指针，并给出了insertR、insertL、removeR、removeL、reverse和show的方法。

主要操作的实现方法：

- move：通过不断更改光标指向的pred和succ来实现其在链表中的向左向右移动。
- insert：插入链表结点，更改光标指向。
- delete：删除链表结点，更改光标指向。
- reverse：定义cursorL和cursorR的位置分别为curPosL和curPosR，初始值分别为0和length，而后根据每次操作的效果加减1更改其位置值，通过比较位置值的大小来判断能否reverse。reverse时，正反向链表互换reverse的部分，总共涉及到12个指针的改变(其中，断口4次，光标2次，因为是双向所以要乘2)。
- show：遍历链表各结点。

## 算法改进

最初采取的方案是构建一个双向链表，reverse时从光标处开始遍历来判断能否reverse，如果能reverse则在两光标所夹区间内遍历来swap data。

然而，每遍历一次链表的单次操作复杂度都是o(n)，这是十分耗时的。于是进行了两代改进：

第二版是添加了curPosL和curPosR，删除了判断能否reverse时的遍历。虽然依然只过了三个点，但是通过的点的耗时减小了2/3，速度明显提升。因此，我意识到遍历链表的物理跳跃性所产生的时间损耗的严重性。

第三版是将reverse的过程中的遍历也去掉了，具体方法就是构建一个一样的反向链表，在每一次插入、删除等操作更改正向链表的同时，也更改反向链表的相应成员。这样在reverse时只需交换二者需reverse的部分，reverse的复杂度从o(n)降为o(1)。

若要进一步精进算法，还可以将链表结点存放在数组里，后继结点只存放下标。访问数组而非访问链表可以减小时间，只存放下标可以减少空间。

## 错误修正

### 15/50：TLE

通过上述算法改进策略通过。

### 75/90：RE（测试点11）

最初并没有找到错误原因，后来按照助教建议写了生成测例的脚本后批量测试才发现错误。

错误构造：cursorL | a | cursorR

错误原因：remove时没有考虑完全。以"D L"为例，remove结点时只考虑了对于`cursorL->succ`的影响，但假如此时右光标的左侧也恰好是要删除的结点，那么`cursorR->pred`也应当改变其指向的点。

### 80/90：RE（测试点12）

错误构造：cursorL&cursorR | a

错误原因：与上一个错误类似，没有在某些情况下相应改变`cursorR->succ`指向的点。

### 85/90：TLE（测试点18）

通过上述算法改进中“将链表结点存放在数组里”的策略通过。

## 复杂度估计

时间复杂度：O(n)

空间复杂度：O(2n)