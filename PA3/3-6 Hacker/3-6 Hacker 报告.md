# 3-6 Hacker 报告

## 实现思路

本题的总体思路是构建一个数组模仿的大小为9999991的链式哈希表，哈希表中entry的key为存储每个字符串加盐后的crc32加密值，value为字符串对应的10进制数以及字符串本身位数。初始化在哈希表放入所有不大于5位的字符串(init函数、Hashtable::put函数)，每次查询操作会访问对应的链(Hashtable::get函数)，然后再根据要求添加新的entry到哈希表(update函数)。

## 实现细节

### 哈希表的设计与表示

本题解法所设计的哈希表并非用桶数组存放词条指针，而是用ht[9999991]数组存储该桶中首个词条数组下标，其好处在于省空间，抛去了不必要的信息。计算得到的key后，定位到对应的ht数组，然后寻着词条中的next向后访问，找到合适的位置返回、插入或查询。

### `EntryList`结构体

```c++
    long long key;   //明文加盐后对应的哈希值
    long long value; //明文的18进制表示转化的10进制数
    int num;         //明文的位数，不超过8位
    int next;        //链表内下一个entry数组的下标
```

1. 由于明文字符串本身是char*型的，存储空间较大，因此考虑将数组转化为long long或int型变量进行存储。首先，将明文字符串视作18进制数，对应方式为`char c[19] = "0123456789tsinghua"`。然后，再利用`diciotto2Dieci`函数将仿18进制数转化为10进制数（最终输出时再调用`dieci2Diciotto`函数转回字符串形式）。由于位数减小会损失一定信息，因此还需要引入`num`变量来记录原字符串的位数。
2. 用`entry[5000719]`存储所有词条（初始18^5+18^4+18^3+18^2+18^1，加上最多100w次操作乘上每次操作最多多3，≤5000718），因为要把相同key的词条“链”起来，因此引入next来表示链表内下一个entry数组的下标。

### 初始化方式

初始化在init函数中完成，通过不断在前字符串crc32值的基础上计算加入新的字符后的crc32值，再把对应的10进制数和位数一起计算后存入哈希表，来完成对1-5长度字符串信息的初始存储。

### `Hashtable`类的方法介绍

Hashtable类中主要包括如下2种方法：

```c++
void put(long long k, long long v, int n) //词条插入
int get(long long k) //词条查找 | 未找到返回0，找到一个返回1，找到多个返回2
```

其中，put方法的大致运行过程是，先调用probe函数计算余数为新词条找到对应的桶ht[r]，若此桶未插入过词条，则写入entry[curNum]数据并令curNum++以定位到新的空桶；若此桶已插入过词条，则需要用链表接续，循着next找到无next的词条并插入其后，同时令curNum++。

get方法与put方法比较相近，其返回值为0、1和2，分别对应No、找到和Duplicate三种状态。在定位到对应的桶ht[r]后，若此桶未插入过词条，则直接返回0；若此桶已插入过词条，则循链表依次核查key、value和num是否相同，找到全相同的用全局变量ans记录，再次出现全相同则需返回2。

### 查询时更新

这一步骤在update函数中完成。虽然题干中每次都需要增加最多8个条目，但事实上只需要增加最多3个，因为长度不大于5的已经在初始化中存入了哈希表。涉及到如下变量：

```c++
char allHead[1000001]; //所有破解的明文的字母头顺序组成的数组
char *curHead;         //当前指向的数组
unsigned int headJoint[3]; //破解结果集合相关数据记录（只包含长度为6、7、8的明文）
```

更新时，需要让curHead游走在allHead数组上，以指向相应位置，便于定位需要从哪里开始计算相关信息。计算结果信息记录在headJoint数组中，每次有新的计算结果时覆盖。

## 错误修正

### 5/50：WA

看错题干，以为每次更新需要删除原先更新加入的，因此写了Hashtable::remove函数。含泪删掉remove。

### 30/50：WA

编写测例生成器，用命令行以10000量级只涉及3个字母的规模进行测试，才发现错误是有雷同词条。这是因为一些逻辑错误，导致没有从ht[r]即开始判断，所以雷同词条会在哈希表中出现最多两次，导致过多的Duplicate。

### 65/90：MLE

初始方法是开辟了桶数组，数组中存放词条指针，这大大消耗了空间。后续进行了改进：用ht[HASHTABLE_SIZE]模仿桶数组，但ht[]中存放的不是词条指针，而是词条数组下标，省了约一半的空间。

## 复杂度估计

时间复杂度：O(n)

空间复杂度：O(C)